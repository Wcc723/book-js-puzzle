<!DOCTYPE html>
<html lang="zh-Hant-TW">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>

  <body>
    <script>
      // ## 15 何謂動態型別?
      // var price = 50;
      // console.log(typeof price); // 'number' 數值型別
      // price = '50 元 ';
      // console.log(typeof price); // 'string' 字串型別


      // ## 16 什麼是顯性轉換與隱性轉換?
      // var price = 50;
      // console.log(price.toString()); // '50'
      // console.log(String(price)); // '50'


      // var price = 50;
      // console.log(price + '');
      // console.log(`${price}`);


      // ## 方法一:原始型別包裹物件及原型方法
      // var price = 50;
      // console.log(String(price)); // '50'
      // console.log(Symbol(price)); // Symbol(50)
      // console.log(Number(price)); // 50
      // console.log(BigInt(price)); // 50n
      // console.log(Boolean(price)); // true


      // var price = 50;
      // console.log(price.toString()); // '50'


      // console.log(String(undefined)); // 'undefined'
      // console.log(undefined.toString()); // Cannot read properties of undefined (reading 'toString')


      // ## 方法二:數值型別轉換
      // var stringPrice = '50 元 ';
      // console.log(Number(stringPrice)); // NaN
      // console.log(Number.parseInt(stringPrice)); // 50
      // console.log(parseInt(stringPrice)); // 50


      // var stringPrice = '50 元 ';
      // console.log(parseInt(stringPrice, 8)); // 40
      // console.log(parseInt(stringPrice, 10)); // 50


      // var stringPrice = '50.5 元 ';
      // console.log(Number(stringPrice)); // NaN
      // console.log(parseInt(stringPrice, 10)); // 50
      // console.log(parseFloat(stringPrice)); // 50.5


      // ## 方法三:正負運算子
      // + '1'; // 一元運算子
      // 1 + '1'; // 二元運算子,部分情境會轉為字串相加


      // var stringPrice = '50';
      // console.log(+stringPrice); // 50
      // console.log(-stringPrice); // -50


      // var stringPrice = '50';
      // console.log(stringPrice + 100); // '50100'
      // console.log(+stringPrice + 100); // 150


      // var stringPrice = '50 元 ';
      // console.log(+stringPrice); // NaN


      // ## 方法四:布林值轉換
      // console.log(Boolean(50)); // true
      // console.log(Boolean(0)); // false


      // console.log(!false); // true
      // console.log(!0); // true
      // console.log(!50); // false


      // console.log(!!false); // false
      // console.log(!!0); // false
      // console.log(!!50); // true


      // !!Boolean(false); // false,正確的邏輯
      // !!new Boolean(false); // true,錯誤的邏輯


      // ## 類型一:+ 運算子
      // console.log(1 + 2); // 3:算術運算子
      // console.log('1' + '1'); // '11':字串串接的字串運算子
      // console.log(1 + '1'); // '11'


      // console.log(1 + [1]); // '11'


      // console.log([1, 2] + [3, 4]); // 1,23,4
      // console.log(1 + {a: 1}); // 1[object Object]
      // console.log(1 + function() {}); // 1function() {}


      // console.log(1 + true); // 2
      // console.log(1 + undefined); // NaN
      // console.log(1 + null); // 1
      // console.log(null + null); // 0
      // console.log(null + true); // 1


      // 1n + 1n // 2n


      // ## 類型二:+= 運算子
      // var a = 1;
      // console.log(a += true); // 2 算術運算子
      // console.log(a += null); // 2 算術運算子
      // console.log(a += []); // '2' 字串運算子


      // var a = 1;
      // console.log(a += Symbol(1)); // 錯誤:Cannot convert a Symbol value to a number
      // var a = 1;
      // console.log(a += 1n); // 錯誤:Cannot mix BigInt and other types, use explicit conversions


      // ## 類型三:算術運算子
      // console.log(1 - ''); // 1:空字串也會被轉型為 0
      // console.log(1 - '1'); // 0:數值運算子,轉型為數值
      // console.log(1 - true); // 0:true 被轉型為 1
      // console.log(1 - null); // 1:null 被轉型為 0
      // console.log(1 - undefined); // NaN:undefined 轉型後為 NaN,任何數值與 NaN 運算結果為 NaN


      // console.log([1].toString()); // '1'
      // console.log([12].toString()); // '12'
      // console.log([1, 2].toString()); // '1,2'
      // console.log({}.toString()); // '[object Object]'
      // // 上述內容套用 Number 的轉型結果
      // console.log(Number([1])); // 1
      // console.log(Number([12])); // 2
      // console.log(Number([1, 2])); // NaN
      // console.log(Number({})); // NaN
      // // 物件套用 toString() 結果為 '[object Object]',所以結果為 NaN


      // console.log([12] - [2]); // 10
      // console.log([1, 2] - [2]); // NaN,因為 [1, 2] 會先轉為字串 1,2,再進行相減


      // ## 其他算術運算子
      // console.log('100' * true);
      // console.log([100] * true);


      // ## 例外狀況
      // console.log(10n * 10n); // 100n:BigInt 僅能與 BinInt 型別計算
      // console.log(1 * Symbol(1)); // Cannot convert a Symbol value to a number


      // ## toString()、String、字串運算子的運作差異
      // var a = 1;
      // console.log(a + ''); // '1'
      // console.log(String(a)); // '1'


      // var a = 1;
      // console.log(a.toString()); // '1'
      // console.log(a.valueOf()); // 1


      // var a = 1;
      // console.log(a + '');
      // console.log(String(a));


      // var num = {
      //   valueOf() {
      //     return 1;
      //   },
      //   toString() {
      //     return 2;
      //   }
      // }
      // console.log(num + ''); // '1'
      // console.log(String(num)); // '2'


      // ## 小節測驗
      // console.log(+[1] + ![] + !![] + [0]);
    </script>
  </body>

</html>