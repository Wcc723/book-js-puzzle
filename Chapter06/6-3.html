<!DOCTYPE html>
<html lang="zh-Hant-TW">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>

  <body>
    <script>
      // ## 物件屬性特徵
      // console.log([1, 2, 3]);


      // function Person(name) {
      //   this.name = name;
      // }
      // Person.prototype.run = function () {
      //   return `${this.name} 快跑啊 `;
      // }
      // var Ming = new Person(' 小明 ');
      // console.log(Ming);


      // ## 37 核心實戰題:什麼是屬性描述器?
      // var person = {};
      // 目標物件 , 屬性名稱 , 特徵
      // Object.defineProperty(person, 'name', {
      //   value: ' 小明 ',
      // });
      // console.log(person); // {name: ' 小明 '}


      // ## writable
      // var person = {};
      // Object.defineProperty(person, 'name', {
      //   value: ' 小明 ',
      //   writable: false, // 不可寫入
      // });
      // person.name = ' 恩娣 ';
      // console.log(person); // {name: ' 小明 '}


      // (() => {
      //   'use strict';
      //   person.name = ' 杰倫 '; // Uncaught TypeError: Cannot assign to read only property 'name' of object '#<Object>'
      // })();


      // ## configurable
      // Object.defineProperty(person, 'name', {
      //   value: ' 小明 ',
      //   configurable: false, // 不可刪除
      // });
      // delete person.name;
      // console.log(person); // {name: ' 小明 '}
      // (() => {
      //   'use strict';
      //   delete person.name; // Uncaught TypeError: Cannot delete property 'name' of #<Object>
      // })();

      // ## enumerable
      // Object.defineProperty(person, 'name', {
      //   value: ' 小明 ',
      //   enumerable: false, // 不可列舉
      // });
      // console.log(Object.keys(person)); // []:空陣列,沒有任何內容
      // for (const key in person) {
      //   console.log(key); // 無法取得值
      // }


      // person.property = ' 這是一般屬性 ';
      // console.log(person);


      // ## 38 原型方法使用 for⋯in 可能會發生什麼狀況?
      // function Person(name) {
      //   this.name = name;
      // }
      // Person.prototype.run = function () {
      //   return `${this.name} 快跑啊 `;
      // }
      // var Ming = new Person(' 小明 ');
      // console.log(Ming);
      // for (const key in Ming) {
      //   console.log(key);
      //   // name
      //   // run
      // }


      // ## 如何避免列舉原型方法
      // console.log(Object.keys(Ming)); // 僅會取得 ['name']


      // for (const key in Ming) {
      //   // 確保是該物件下的屬性,而不是原型
      //   if (Object.hasOwnProperty.call(Ming, key)) {
      //     const element = Ming[key];
      //     console.log(element); // 小明
      //   }
      // }


      // ## 39 請說明 getter、setter 如何運作?
      // var money = {
      //   total: 100,
      //   set save(m) {
      //     this.total = this.total + m / 2;
      //   },
      //   // 注意,執行時並非使用函式的方法,亦不可傳入參數
      //   get hope() {
      //     return this.total * 2;
      //   }
      // }


      // console.log(money);
      // console.log(money.hope);


      // money.save = 1000;
      // console.log(money); // { total: 600, hope: (...) }


      // ## 小節測驗
      // ## 1. 請問以下的執行後的值為?
      // var product = {
      //   price: 100,
      //   get priceIncludingTax() {
      //     return this.price + this.price * 0.05;
      //   }
      // }
      // console.log(product.priceIncludingTax);
    </script>
  </body>

</html>